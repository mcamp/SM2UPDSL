/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.assa.sm.tests

import com.google.inject.Inject
import dk.sdu.mmmi.assa.sm.stateMachine.Root
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static extension org.junit.Assert.assertFalse
import static extension org.junit.Assert.assertNull
import static extension org.junit.Assert.assertTrue
import static extension org.junit.jupiter.api.Assertions.assertEquals

@ExtendWith(InjectionExtension)
@InjectWith(StateMachineInjectorProvider)
class StateMachineParsingTest {
	@Inject extension ParseHelper<Root> parseHelper

	
	@Test
	def void loadModel() {
		val result = parseHelper.parse('''
			project test
			machine test {}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void singleMachine() {
		val root = '''
			project test
			machine test {}
		'''.parse
		"test".assertEquals(root.name)
		"test".assertEquals(root.machines.get(0).name)
	}
	
	@Test
	def void states() {
		val root = '''
			project test
			machine test {
				state one
				state two
			}
		'''.parse
		val machine = root.machines.get(0)
		2.assertEquals(machine.states.size)
		"one".assertEquals(machine.states.get(0).name)
		"two".assertEquals(machine.states.get(1).name)
	}
	
	@Test
	def void transition() {
		val root = '''
			project test
			machine test {
				state one
				state two
				one -> two
			}
		'''.parse
		val transition = root.machines.get(0).transitions.get(0)
		root.machines.get(0).states.get(0).assertEquals(transition.from)
		root.machines.get(0).states.get(1).assertEquals(transition.to)
		transition.when.assertNull()
	}
	
	@Test
	def void transitionWhen() {
		val root = '''
			project test
			machine test {
				state one
				state two
				one -> two when play
			}
		'''.parse
		val transition = root.machines.get(0).transitions.get(0)
		root.machines.get(0).states.get(0).assertEquals(transition.from)
		root.machines.get(0).states.get(1).assertEquals(transition.to)
		"play".assertEquals(transition.when)
	}
	
	@Test
	def void transitionSignal() {
		val root = '''
			project test
			machine test {
				state one
				state two
				one -> two signal play
			}
		'''.parse
		val transition = root.machines.get(0).transitions.get(0)
		root.machines.get(0).states.get(0).assertEquals(transition.from)
		root.machines.get(0).states.get(1).assertEquals(transition.to)
		"play".assertEquals(transition.signal)
	}
	
	@Test
	def void failState() {
		val root = '''
			project test
			machine test {
				state one
				state two
				fail state failState
				two -> failState when sthFail
			}
		'''.parse
		root.machines.get(0).states.get(0).isFail.assertFalse
		root.machines.get(0).states.get(2).isFail.assertTrue
	}
	
	@Test
	def void nestedMachine() {
		val root = '''
			project test
			machine test {
				state one
				state two with machine inner{ 
					state one
					state three
					one -> three when sthInside
				}
			}
		'''.parse
		val nestedMachine = root.machines.get(0).states.get(1).machine
		'inner'.assertEquals(nestedMachine.name)
		2.assertEquals(nestedMachine.states.size)
		'one'.assertEquals(nestedMachine.states.get(0).name)
		'three'.assertEquals(nestedMachine.states.get(1).name)
		1.assertEquals(nestedMachine.transitions.size)
	}
	
	@Test
	def void timeTransition() {
		val root = '''
			project test
			machine test {
				state one
				state two
				one -> two after 500
			}
		'''.parse
		val transition= root.machines.get(0).transitions.head
		root.machines.get(0).states.get(0).assertEquals(transition.from)
		root.machines.get(0).states.get(1).assertEquals(transition.to)
		transition.isTime.assertTrue
		500.assertEquals(transition.timeout)
	}
	
	@Test
	def void signalTimeoutTransition() {
		val root = '''
			project test
			machine test {
				state one
				state two
				one -> two after 5 signal finish
			}
		'''.parse
		val transition= root.machines.get(0).transitions.head
		root.machines.get(0).states.get(0).assertEquals(transition.from)
		root.machines.get(0).states.get(1).assertEquals(transition.to)
		transition.isTime.assertTrue
		5.assertEquals(transition.timeout)
		'finish'.assertEquals(transition.signal)
	}
	
	
	@Test
	def void multipleMachine() {
		val root = '''
			project test
			machine m1 {
				state one
			}
			machine m2 {
				state two
			}
		'''.parse
		2.assertEquals(root.machines.size)
		"m1".assertEquals(root.machines.get(0).name)
		1.assertEquals(root.machines.get(0).states.size)
		"one".assertEquals(root.machines.get(0).states.get(0).name)
		
		"m2".assertEquals(root.machines.get(1).name)
		1.assertEquals(root.machines.get(1).states.size)
		"two".assertEquals(root.machines.get(1).states.get(0).name)
	}
	
	@Test
	def void guardTransition() {
		val root = '''
			project test
			machine m1 {
				state one
				state two
				one -> two guard false
				one -> two guard true
			}
		'''.parse
		root.machines.get(0).transitions.get(0).guard.assertFalse
		root.machines.get(0).transitions.get(1).guard.assertTrue
	}
	
	@Test
	def void guardAndSignalTransition() {
		val root = '''
			project test
			machine m1 {
				state one
				state two
				one -> two guard false signal signal1
				one -> two guard true signal signal2
			}
		'''.parse
		val tx1 = root.machines.get(0).transitions.get(0)
		val tx2 = root.machines.get(0).transitions.get(1)
		tx1.guard.assertFalse
		"signal1".assertEquals(tx1.signal)
		
		tx2.guard.assertTrue
		"signal2".assertEquals(tx2.signal)
		
	}

}
